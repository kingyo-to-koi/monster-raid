<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Monster Raid (Vanilla JS)</title>
    <style>
      :root {
        --bg: #0f0f14;
        --panel: #171724;
        --panel2: #1e1e2e;
        --text: #eaeaf0;
        --muted: #a9aac0;
        --line: #2d2d44;
        --btn: #2e2e44;
        --btn2: #3a3a56;
        --danger: #ff5d5d;
        --ok: #5dffa5;
        --warn: #ffd15d;
        --accent: #7aa0ff;
        --chip: #26263a;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 16px;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: var(--bg);
        color: var(--text);
      }
      h2,
      h3,
      h4 {
        margin: 8px 0;
      }
      small {
        color: var(--muted);
      }
      .app {
        display: grid;
        grid-template-columns: 1fr 1.2fr 1fr;
        gap: 12px;
        min-height: calc(100vh - 32px);
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 12px;
        overflow: auto;
      }
      .panel header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .col {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      input,
      select {
        background: var(--panel2);
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 5px 8px;
        outline: none;
        min-width: 0px;
        font-size: 13px;
      }
      input[type="number"] {
        width: 56px;
        height: 30px;
        min-width: 0;
      }
      button {
        background: var(--btn);
        color: var(--text);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px 10px;
        cursor: pointer;
      }
      button:hover {
        background: var(--btn2);
      }
      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      .hr {
        height: 1px;
        background: var(--line);
        margin: 10px 0;
      }
      .cards {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 3px 8px;
        border-radius: 999px;
        background: var(--chip);
        border: 1px solid var(--line);
        font-size: 12px;
        color: var(--muted);
        margin-right: 6px;
        margin-bottom: 6px;
        white-space: nowrap;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
      }
      .statgrid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
        margin-top: 8px;
      }
      .statline {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        padding: 6px 8px;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid var(--line);
        border-radius: 8px;
        font-size: 12px;
      }
      .hpbar {
        height: 14px;
        background: #0b0b12;
        border: 1px solid #2d2d44;
        border-radius: 999px;
        overflow: hidden;
      }

      .hpfill {
        height: 100%;
        transition: width 0.3s ease;
      }

      .hpfill.high {
        background: #5dffa5;
      } /* 60% ì´ìƒ */
      .hpfill.mid {
        background: #ffd15d;
      } /* 30~59% */
      .hpfill.low {
        background: #ff5d5d;
      } /* 0~29% */
      .danger {
        color: var(--danger);
      }
      .ok {
        color: var(--ok);
      }
      .warn {
        color: var(--warn);
      }
      .log {
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
      }
      .stickyFooter {
        position: sticky;
        bottom: 0;
        background: linear-gradient(
          transparent,
          rgba(15, 15, 20, 0.85) 25%,
          rgba(15, 15, 20, 0.95)
        );
        padding-top: 8px;
        margin-top: 8px;
      }
      .actionRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
      }
      .actionRow > div {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .wide {
        min-width: 220px;
      }
      .pillBtn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 8px 12px;
      }
      .mini {
        padding: 6px 8px;
        font-size: 12px;
        border-radius: 8px;
      }
      .rightMeta {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: flex-end;
      }

      .skillSelect {
        min-width: 0; /* â­ ê°€ì¥ ì¤‘ìš” */
        max-width: 100%;
        padding: 6px 8px; /* ë†’ì´ ì¤„ì´ê¸° */
        font-size: 12px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* ì¤‘ì•™ í–‰ë™ ì„ íƒ ì¹´ë“œ 2ì—´ ë°°ì¹˜ */
      #playerActionCards {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: start;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <!-- LEFT: creation -->
      <section class="panel" id="leftPanel">
        <header>
          <div>
            <h2>ìƒì„±</h2>
            <small>ìºë¦­í„° ìµœëŒ€ 8ëª… / ëª¬ìŠ¤í„° ìµœëŒ€ 4ë§ˆë¦¬</small>
          </div>
          <div class="rightMeta">
            <span class="chip mono" id="roundChip">ROUND 1</span>
            <span class="chip mono" id="phaseChip">PHASE: HINT</span>
          </div>
        </header>

        <div class="card">
          <h3>ìºë¦­í„° ìƒì„±</h3>

          <div class="row">
            <div class="col">
              <label>ì´ë¦„</label>
              <input id="pName" placeholder="ì˜ˆ: ë§ˆë¦¬" />
            </div>

            <div class="col">
              <label>ì§êµ°</label>
              <select id="pRole">
                <option value="TANK">íƒ±ì»¤</option>
                <option value="DPS">ë”œëŸ¬</option>
                <option value="SUPPORT">ì„œí¬í„°</option>
              </select>
            </div>
          </div>

          <div class="hr"></div>

          <div class="row">
            <div class="col">
              <label>ì²´ë ¥</label>
              <input id="pVit" type="number" min="1" max="12" value="7" />
            </div>
            <div class="col">
              <label>ê³µê²©</label>
              <input id="pAtk" type="number" min="1" max="12" value="7" />
            </div>
            <div class="col">
              <label>ë°©ì–´</label>
              <input id="pDef" type="number" min="1" max="12" value="6" />
            </div>
            <div class="col">
              <label>ë¯¼ì²©</label>
              <input id="pAgi" type="number" min="1" max="12" value="6" />
            </div>
          </div>
          <small id="sumHint" class="warn">íŒ¨ì‹œë¸Œ í¬í•¨ ìŠ¤íƒ¯ 28</small>

          <div class="hr"></div>

          <div class="row">
            <div class="col" style="flex: 1">
              <label>ì•¡í‹°ë¸Œ(íƒ2)</label>
              <select id="pActive1" class="wide skillSelect"></select>
              <select id="pActive2" class="wide skillSelect"></select>
              <small class="muted">ì•¡í‹°ë¸ŒëŠ” ì—°ì† ì‚¬ìš© ë¶ˆê°€ (Aâ†’A ë¶ˆê°€)</small>
            </div>
            <div class="col" style="flex: 1">
              <label>ê¶ê·¹ê¸°(íƒ1)</label>
              <select id="pUlt" class="wide skillSelect"></select>
              <small class="muted">ëŸ¬ë‹ ì¤‘ 1íšŒ</small>
            </div>
          </div>

          <div class="row" style="margin-top: 10px">
            <button id="addPlayerBtn" class="pillBtn">+ ìºë¦­í„° ì¶”ê°€</button>
            <button id="clearPlayersBtn" class="mini">ìºë¦­í„° ì´ˆê¸°í™”</button>
          </div>
        </div>

        <div class="card">
          <h3>ëª¬ìŠ¤í„° ìƒì„±</h3>

          <div class="row">
            <div class="col">
              <label>ì´ë¦„</label>
              <input id="mName" placeholder="ì˜ˆ: MONSTER A" />
            </div>
            <div class="col">
              <label>HP(ê¸°ë³¸)</label>
              <input
                id="mHpBase"
                type="number"
                min="50"
                max="5000"
                value="500"
              />
            </div>
          </div>

          <div class="row">
            <div class="col">
              <label>ì²´ë ¥</label>
              <input id="mVit" type="number" min="1" max="20" value="10" />
            </div>
            <div class="col">
              <label>ê³µê²©</label>
              <input id="mAtk" type="number" min="1" max="20" value="8" />
            </div>
            <div class="col">
              <label>ë°©ì–´</label>
              <input id="mDef" type="number" min="1" max="20" value="6" />
            </div>
            <div class="col">
              <label>ë¯¼ì²©</label>
              <input id="mAgi" type="number" min="1" max="20" value="6" />
            </div>
          </div>

          <div class="row" style="margin-top: 10px">
            <button id="addMonsterBtn" class="pillBtn">+ ëª¬ìŠ¤í„° ì¶”ê°€</button>
            <button id="clearMonstersBtn" class="mini">ëª¬ìŠ¤í„° ì´ˆê¸°í™”</button>
          </div>
        </div>

        <div class="card">
          <h3>ì „íˆ¬ ì œì–´</h3>
          <div class="row">
            <button id="startRoundBtn" class="pillBtn">1) ë¼ìš´ë“œ ì‹œì‘</button>
            <button id="resolveBtn" class="pillBtn">2) ë¼ìš´ë“œ í•©ì‚°</button>
            <button id="resetBattleBtn" class="mini">ì „íˆ¬ ë¦¬ì…‹</button>
          </div>
          <small class="muted">
            íë¦„: ë¼ìš´ë“œ ì‹œì‘(ëª¬ìŠ¤í„° í–‰ë™ ì•”ì‹œ) â†’ ì¤‘ì•™ì—ì„œ í”Œë ˆì´ì–´ í–‰ë™ ì„ íƒ â†’
            ë¼ìš´ë“œ í•´ì„(í”Œë ˆì´ì–´â†’ëª¬ìŠ¤í„°â†’ìµœì¢… í•©ì‚°)
          </small>
        </div>
      </section>

      <!-- CENTER: actions -->
      <section class="panel" id="centerPanel">
        <header>
          <div>
            <h2>í–‰ë™ ì„ íƒ</h2>
            <small>ê° í”Œë ˆì´ì–´ì˜ í–‰ë™/ìŠ¤í‚¬/ëŒ€ìƒì„ ì„¤ì •</small>
          </div>
        </header>

        <div class="card">
          <h3>í˜„ì¬ ì•”ì‹œ</h3>
          <div id="hintBox" class="log">
            ë¼ìš´ë“œ ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì•”ì‹œë¥¼ ìƒì„±í•˜ì„¸ìš”.
          </div>
        </div>

        <div class="cards" id="playerActionCards"></div>

        <div class="stickyFooter">
          <div class="row" style="justify-content: space-between">
            <div class="row">
              <button id="autoFillBtn" class="mini">
                ìë™ ì…ë ¥(ê¸°ë³¸ ê³µê²©)
              </button>
              <button id="clearActionsBtn" class="mini">í–‰ë™ ì´ˆê¸°í™”</button>
            </div>
            <div class="row">
              <span class="chip mono" id="readyChip">READY: 0/0</span>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: logs -->
      <section class="panel" id="rightPanel">
        <header>
          <div>
            <h2>ë¡œê·¸</h2>
            <small>HP/ìŠ¤íƒ¯ ë³€í™”, ìƒíƒœì´ìƒ, í”¼í•´/ê²½ê° ë‚´ì—­</small>
          </div>
          <div class="row">
            <button id="copyLogBtn" class="mini">ë¡œê·¸ ë³µì‚¬</button>
            <button id="clearLogBtn" class="mini">ë¡œê·¸ ë¹„ìš°ê¸°</button>
          </div>
        </header>

        <div class="card">
          <h3>ëª¬ìŠ¤í„° ìƒíƒœ</h3>
          <div id="monsterState" class="log">ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        </div>

        <div class="card">
          <h3>í”Œë ˆì´ì–´ ìƒíƒœ</h3>
          <div id="playerState" class="log">í”Œë ˆì´ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
        </div>

        <div class="card">
          <h3>ì „íˆ¬ ë¡œê·¸</h3>
          <div id="battleLog" class="log"></div>
        </div>
      </section>
    </div>

    <script>
      /* =========================
               Utilities
            ========================= */
      const d6 = () => Math.floor(Math.random() * 6) + 1;
      const d10 = () => Math.floor(Math.random() * 10) + 1;
      const d5 = () => Math.floor(Math.random() * 5) + 1;
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const pct = (p) => Math.random() * 100 < p;
      const nowTime = () => new Date().toLocaleTimeString();

      function hpBarHTML(hp, maxHp) {
        const ratio = maxHp > 0 ? hp / maxHp : 0;
        const percent = Math.max(0, Math.min(100, Math.floor(ratio * 100)));

        let cls = "high";
        if (percent < 30) cls = "low";
        else if (percent < 60) cls = "mid";

        return `
                <div class="hpbar">
                  <div class="hpfill ${cls}" style="width:${percent}%"></div>
                </div>
                <div class="mono" style="font-size:11px; color:#aaa">
                  ${hp} / ${maxHp} (${percent}%)
                </div>
              `;
      }

      const ROLE_LABEL = {
        TANK: "íƒ±ì»¤",
        DPS: "ë”œëŸ¬",
        SUPPORT: "ì„œí¬í„°",
      };

      function deepCopy(obj) {
        return JSON.parse(JSON.stringify(obj));
      }

      function fmtHp(hp, max) {
        const p =
          max > 0
            ? Math.max(0, Math.min(100, Math.round((hp / max) * 100)))
            : 0;
        return `${hp}/${max} (${p}%)`;
      }

      function makeId(prefix) {
        return prefix + "_" + Math.random().toString(36).slice(2, 9);
      }

      /* =========================
               Game Data
            ========================= */
      const game = {
        round: 1,
        phase: "HINT", // HINT | PLAYER | RESOLVE
        players: [],
        monsters: [],
        // per round
        monsterIntents: null, // {type, text, targets?}
        actions: new Map(), // playerId -> action object
        logLines: [],
      };

      /* =========================
               Rules & Skills
            ========================= */
      const ROLE = { TANK: "TANK", DPS: "DPS", SUPPORT: "SUPPORT" };

      const SKILLS = {
        TANK: {
          active: [
            {
              key: "GUARD",
              name: "í˜¸ìœ„",
              desc: "1í„´ê°„ ì§€ì • 2ì¸ì—ê²Œ ìì‹ ì˜ ìµœì¢… ë°©ì–´ ê°’*0.5 ë³´í˜¸ë§‰",
              target: "ALLY2",
            },
            {
              key: "PROTECT",
              name: "ìˆ˜í˜¸",
              desc: "1í„´ê°„ ì§€ì • 1ì¸ì˜ í”¼í•´ë¥¼ ëŒ€ì‹  ë°›ì•„ë‚¸ë‹¤. ì´ ë•Œ, ì‹œì „ìì˜ ë°©ì–´ê°’ì€ 1.3ë°° ì¶”ê°€ëœë‹¤.",
              target: "ALLY1",
            },
            {
              key: "ENDURE",
              name: "ì¸ë‚´",
              desc: "3í„´ê°„ ë°›ì€ í”¼í•´ ëˆ„ì  â†’ ì¢…ë£Œ ì‹œ ëˆ„ì *0.5 ë˜ëŒë ¤ì¤Œ(ëœë¤ ëª¬ìŠ¤í„°)",
              target: "NONE",
            },
            {
              key: "FIGHTING_SPIRIT",
              name: "íˆ¬í˜¼",
              desc: "2í„´ê°„ ë°©ì–´ ìŠ¤íƒ¯ -5, ë§¤ í„´ ì§€ì • ì  1ì—ê²Œ ê³ ì • 100",
              target: "ENEMY1",
            },
          ],
          ult: [
            {
              key: "UNYIELDING",
              name: "ë¶ˆêµ´",
              desc: "1í„´ê°„ ëª¨ë“  ì•„êµ° í”¼í•´/ë””ë²„í”„ë¥¼ ë³¸ì¸ì´ ë°›ìŒ. ì²´ë ¥ì€ 1 ë¯¸ë§Œìœ¼ë¡œ ë‚´ë ¤ê°€ì§€ ì•ŠìŒ",
              target: "NONE",
            },
            {
              key: "DEVOTION",
              name: "í—Œì‹ ",
              desc: "í˜„ì¬ ì²´ë ¥ 100% ì†Œëª¨ í›„ ìµœì¢… ë°©ì–´ê°’*2 ë§Œí¼ ì  ì „ì²´ ê³µê²©",
              target: "ENEMY_ALL",
            },
          ],
        },
        DPS: {
          active: [
            {
              key: "MADNESS",
              name: "ê´‘ê¸°",
              desc: "ë‹¤ìŒ í„´ ê³µê²© ìŠ¤íƒ¯ +2 (ì¤‘ì²© ê°€ëŠ¥)",
              target: "NONE",
            },
            {
              key: "OBSESSION",
              name: "ì§‘ë…",
              desc: "3í„´ê°„ ì§€ì • ì  1ì—ê²Œ ê¸°ë³¸ ê³µê²©ê°’*0.5 ì§€ì† í”¼í•´(ì¤‘ì²© ê°€ëŠ¥)",
              target: "ENEMY1",
            },
            {
              key: "BLOODFIGHT",
              name: "í˜ˆíˆ¬",
              desc: "í˜„ì¬ ì²´ë ¥ 50% ì†Œëª¨ í›„ ì§€ì • ì  1ì—ê²Œ ìµœì¢… ê³µê²©ê°’*1.5",
              target: "ENEMY1",
            },
            {
              key: "MASSACRE",
              name: "ì°¸ì‚´",
              desc: "ì  ì „ì²´ì—ê²Œ ìµœì¢… ê³µê²©ê°’*0.8",
              target: "ENEMY_ALL",
            },
          ],
          ult: [
            {
              key: "MERCY",
              name: "ìë¹„",
              desc: "ê³µê²© ë‹¤ì´ìŠ¤ 2íšŒ í•©ì‚° í›„ ìµœì¢… ê³µê²©ê°’*2",
              target: "ENEMY1",
            },
            {
              key: "CHARGE",
              name: "ëŒê²©",
              desc: "ì  ë°©ì–´ê°’ ë¬´ì‹œ, ìµœì¢… ëŒ€ë¯¸ì§€ë¡œ ê³µê²©",
              target: "ENEMY1",
            },
          ],
        },
        SUPPORT: {
          active: [
            {
              key: "REVIVE",
              name: "íšŒìƒ",
              desc: "ì§€ì • 1ì¸ ì²´ë ¥ì„ ìµœì¢… ë¯¼ì²©ê°’ ë§Œí¼ íšŒë³µ",
              target: "ALLY1",
            },
            {
              key: "BLESS",
              name: "ê°€í˜¸",
              desc: "ì§€ì • 2ì¸ ì²´ë ¥ì„ ìµœì¢… ë¯¼ì²©ê°’*0.5 ë§Œí¼ íšŒë³µ",
              target: "ALLY2",
            },
            {
              key: "ENCOURAGE",
              name: "ê²©ë ¤",
              desc: "1í„´ê°„ ì§€ì • 1ì¸ì˜ ì§€ì • ìŠ¤íƒ¯ +2 (ì¤‘ì²© ê°€ëŠ¥)",
              target: "ALLY1_STAT",
            },
            {
              key: "PURIFY",
              name: "ì •í™”",
              desc: "ì§€ì • 2ì¸ì˜ ë””ë²„í”„ í•´ì œ",
              target: "ALLY2",
            },
            {
              key: "PENANCE",
              name: "ì°¸íšŒ",
              desc: "ì§€ì • ì  1ì¸ì˜ ìµœì¢… ê³µê²©ê°’ì„ (ë³¸ì¸ ìµœì¢… ë¯¼ì²©ê°’*0.5)ë§Œí¼ ê°ì†Œ(ì¤‘ì²© ë¶ˆê°€, 1í„´)",
              target: "ENEMY1",
            },
          ],
          ult: [
            {
              key: "REINCARNATION",
              name: "ìœ¤íšŒ",
              desc: "ì§€ì • ì•„êµ° 1ì¸ì˜ ê¶ê·¹ê¸° íšŸìˆ˜ ì´ˆê¸°í™”",
              target: "ALLY1",
            },
            {
              key: "REST",
              name: "ì•ˆì‹",
              desc: "ì „ì²´ ì•„êµ° 100% íšŒë³µ + ë‹¤ìš´ ëŒ€ê¸° ì œê±°(ì¦‰ì‹œ ë¶€í™œ)",
              target: "ALLY_ALL",
            },
          ],
        },
      };

      /* =========================
               Entity model
            ========================= */
      function makePlayer({ name, role, vit, atk, def, agi, actives, ult }) {
        const maxHp = 150 + vit * 10;
        return {
          id: makeId("P"),
          type: "PLAYER",
          name,
          role,
          base: { vit, atk, def, agi },
          // dynamic buffs (turn-based)
          temp: {
            atkPlus: 0, // from MADNESS (applies next turn) and ENCOURAGE etc.
            defPlus: 0,
            agiPlus: 0,
            vitPlus: 0,
          },
          hp: maxHp,
          maxHp,
          down: false,
          downCounter: 0, // when >0 cannot act; when reaches 0 -> revive 30%
          ultUsed: false,
          actives,
          ult,
          lastActiveKey: null,
          // states
          shields: [], // [{value, expiresRound}]
          redirect: null, // {tankId, reduction} applied to this player
          tankingAll: false, // UNYIELDING flag on tank
          minHpFloor: false, // if true: hp cannot drop below 1 this round
          debuffs: [], // [{type, value, turns, sourceId}]
          dots: [], // [{type, value, turns, sourceId}] ticking each round start
          endure: null, // {accum, turnsLeft}
          fightingSpirit: null, // {targetId, turnsLeft}
          pendingAtkPlusNext: 0, // for MADNESS stacking
        };
      }

      function makeMonster({ name, vit, atk, def, agi, hpBase }) {
        const maxHp = hpBase; // monster HP is manual base as requested
        return {
          id: makeId("M"),
          type: "MONSTER",
          name,
          base: { vit, atk, def, agi },
          temp: { atkPlus: 0, defPlus: 0, agiPlus: 0, vitPlus: 0 },
          hp: maxHp,
          maxHp,
          alive: true,
          buffs: [],
          debuffs: [],
          dots: [],
          shields: [],
          // monster-specific
        };
      }

      /* =========================
               Combat Calculations
            ========================= */
      function effectiveStat(entity, key) {
        const base = entity.base[key] || 0;

        // í”Œë ˆì´ì–´ temp ìŠ¤íƒ¯ (ê²©ë ¤ ë“±)
        const plusKey = key + "Plus";
        const plus = entity.temp?.[plusKey] || 0;

        // ëª¬ìŠ¤í„° ìê°€ë²„í”„ í•©ì‚°
        let buff = 0;
        if (entity.buffs) {
          for (const b of entity.buffs) {
            if (b.stat === key) {
              buff += b.value;
            }
          }
        }

        // special: fighting spirit reduces DEF base stat by 5 while active (tank only)
        let special = 0;
        if (
          entity.type === "PLAYER" &&
          entity.fightingSpirit &&
          key === "def"
        ) {
          special -= 5;
        }

        return clamp(base + plus + buff + special, 0, 99);
      }

      // "final stat value" as used in skills: stat * 1d6
      function finalStat(entity, key) {
        const s = effectiveStat(entity, key);
        return s * d6();
      }

      function critChance(entity) {
        // only base agility stat (initial), not buffs: per spec
        const p = clamp(entity.base.agi, 0, 100);
        return p;
      }

      function baseAttackDamage(attacker) {
        const atk = effectiveStat(attacker, "atk");
        const roll = d6();
        return atk * roll;
      }

      function baseDefenseMitigation(defender, defMult = 1.0) {
        const def = effectiveStat(defender, "def");
        const roll = d6();
        return Math.floor(def * defMult * roll);
      }

      function consumeShield(defender, dmg) {
        if (dmg <= 0) return { dmg: 0, absorbed: 0 };
        let remaining = dmg;
        let absorbed = 0;
        // shields consume oldest first
        defender.shields.sort((a, b) => a.expiresRound - b.expiresRound);
        for (const sh of defender.shields) {
          if (remaining <= 0) break;
          const take = Math.min(sh.value, remaining);
          sh.value -= take;
          remaining -= take;
          absorbed += take;
        }
        defender.shields = defender.shields.filter((s) => s.value > 0);
        return { dmg: remaining, absorbed };
      }

      function applyDamage(
        defender,
        rawDmg,
        { ignoreDefense = false, sourceText = "", allowFloor = false } = {}
      ) {
        if (defender.type === "MONSTER" && !defender.alive)
          return { dealt: 0, mitigated: 0, absorbed: 0 };

        // downed still can take damage (keeps at 0), but we'll allow
        let dmg = Math.max(0, Math.floor(rawDmg));

        // shields first
        const shieldRes = consumeShield(defender, dmg);
        dmg = shieldRes.dmg;

        let mitigated = 0;

        if (!ignoreDefense) {
          const mit = baseDefenseMitigation(defender, 1.0);
          mitigated += Math.min(mit, dmg);
          dmg = Math.max(0, dmg - mit);
        }

        // defend action adds extra mitigation stored on defender this round
        if (defender._defendBonus && !ignoreDefense) {
          const extra = defender._defendBonus;
          mitigated += Math.min(extra, dmg);
          dmg = Math.max(0, dmg - extra);
        }

        const beforeHp = defender.hp;
        defender.hp = Math.max(0, defender.hp - dmg);

        // UNYIELDING floor (hp cannot go below 1)
        if (defender.type === "PLAYER") {
          if (defender.minHpFloor || allowFloor) {
            if (defender.hp < 1) defender.hp = 1;
          }
        }

        // monster alive flag
        if (defender.type === "MONSTER") {
          if (defender.hp <= 0) {
            defender.alive = false;
            defender.hp = 0;
          }
        }

        const dealt = beforeHp - defender.hp;

        return {
          dealt,
          mitigated,
          absorbed: shieldRes.absorbed,
        };
      }

      function heal(target, amount) {
        const v = Math.max(0, Math.floor(amount));
        const before = target.hp;
        target.hp = Math.min(target.maxHp, target.hp + v);
        return target.hp - before;
      }

      function setDownIfNeeded(player) {
        if (player.type !== "PLAYER") return;
        if (player.hp <= 0 && !player.down) {
          player.down = true;
          player.downCounter = 2; // 1í„´ ëŒ€ê¸° í›„ 2í„´ì—ì„œ(=2ë¼ìš´ë“œ í›„) í–‰ë™ ê°€ëŠ¥ìœ¼ë¡œ êµ¬í˜„
          player.hp = 0;
        }
      }

      function reviveIfReady(player) {
        if (player.type !== "PLAYER") return;
        if (player.down) {
          player.downCounter = Math.max(0, player.downCounter - 1);
          if (player.downCounter === 0) {
            player.down = false;
            player.hp = Math.max(1, Math.floor(player.maxHp * 0.3));
            log(`â†º ${player.name} ì†Œìƒ: HP ${player.hp}/${player.maxHp} (30%)`);
          }
        } else {
          // apply "madness" pending atk+ for this round start
          if (player.pendingAtkPlusNext > 0) {
            player.temp.atkPlus += player.pendingAtkPlusNext;
            log(
              `â–² ${player.name} ê³µê²© +${player.pendingAtkPlusNext} (ê´‘ê¸° ì ìš©)`
            );
            player.pendingAtkPlusNext = 0;
          }
        }
      }

      /* =========================
               DOT / Debuff
            ========================= */
      function addDot(target, dot) {
        target.dots.push(dot);
      }
      function addDebuff(target, debuff) {
        // PENANCE not stackable
        if (debuff.type === "PENANCE") {
          if (target.debuffs.some((d) => d.type === "PENANCE")) return false;
        }
        target.debuffs.push(debuff);
        return true;
      }
      function clearDebuffs(target) {
        target.debuffs = [];
      }
      function tickDots() {
        // tick at round start
        for (const p of game.players) {
          if (p.type !== "PLAYER") continue;
          if (p.down) continue; // downed does not tick? if you prefer tick, remove this line.
          let total = 0;
          const kept = [];
          for (const d of p.dots) {
            total += d.value;
            d.turns -= 1;
            if (d.turns > 0) kept.push(d);
          }
          if (total > 0) {
            const res = applyDamage(p, total, { sourceText: "DOT" });
            log(
              `ğŸ©¸ ${p.name} DOT í”¼í•´ ${total} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
            );
            setDownIfNeeded(p);
          }
          p.dots = kept;
        }
        for (const m of game.monsters) {
          if (!m.alive) continue;
          let total = 0;
          const kept = [];
          for (const d of m.dots) {
            total += d.value;
            d.turns -= 1;
            if (d.turns > 0) kept.push(d);
          }
          if (total > 0) {
            const res = applyDamage(m, total, { sourceText: "DOT" });
            log(
              `ğŸ©¸ ${m.name} DOT í”¼í•´ ${total} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
            );
          }
          m.dots = kept;
        }
      }

      function applyDebuffsToMonsterAttack(monster, base) {
        // PENANCE: reduce final attack by supporter final agi*0.5 (stored as value)
        let reduced = 0;
        for (const d of monster.debuffs) {
          if (d.type === "PENANCE") {
            reduced += d.value;
          }
        }
        return Math.max(0, base - reduced);
      }

      function decayDebuffsEndRound() {
        // decrement debuffs duration, remove expired
        for (const e of [...game.players, ...game.monsters]) {
          const kept = [];
          for (const d of e.debuffs) {
            d.turns -= 1;
            if (d.turns > 0) kept.push(d);
          }
          e.debuffs = kept;
          // --- â­ ëª¬ìŠ¤í„° ë²„í”„ ê°ì†Œ (ì¶”ê°€ ë¶€ë¶„) ---
          if (e.buffs) {
            const keptBuffs = [];
            for (const b of e.buffs) {
              b.turns -= 1;
              if (b.turns > 0) keptBuffs.push(b);
            }
            e.buffs = keptBuffs;
          }
        }
      }

      /* =========================
               Logging & UI sync
            ========================= */
      function log(line) {
        game.logLines.push(`[${nowTime()}] ${line}`);
        const el = document.getElementById("battleLog");
        el.textContent = game.logLines.slice(-500).join("\n");
        el.scrollTop = el.scrollHeight;
        renderStates();
      }

      function renderStates() {
        // Monster state
        const ms = document.getElementById("monsterState");
        if (game.monsters.length === 0) {
          ms.textContent = "ëª¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.";
        } else {
          const lines = [];
          for (const m of game.monsters) {
            const alive = m.alive ? "ALIVE" : "DEAD";
            const deb = m.debuffs
              .map((d) => `${d.type}:${d.value}(${d.turns})`)
              .join(", ");
            const dot = m.dots
              .map((d) => `${d.type}:${d.value}(${d.turns})`)
              .join(", ");
            lines.push(
              `${m.name} [${alive}] HP ${fmtHp(
                m.hp,
                m.maxHp
              )} | ê³µê²© ${effectiveStat(m, "atk")} ë°©ì–´ ${effectiveStat(
                m,
                "def"
              )} ë¯¼ì²© ${effectiveStat(m, "agi")}` +
                (deb ? ` | DEBUFF {${deb}}` : "") +
                (dot ? ` | DOT {${dot}}` : "")
            );
          }
          ms.textContent = lines.join("\n");
        }

        // Player state
        const ps = document.getElementById("playerState");
        if (game.players.length === 0) {
          ps.textContent = "í”Œë ˆì´ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.";
        } else {
          const lines = [];
          for (const p of game.players) {
            const state = p.down ? `DOWN(${p.downCounter})` : "OK";
            const shields = p.shields
              .map((s) => `${Math.floor(s.value)}@R${s.expiresRound}`)
              .join(",");
            const deb = p.debuffs
              .map((d) => `${d.type}:${d.value}(${d.turns})`)
              .join(", ");
            const dot = p.dots
              .map((d) => `${d.type}:${d.value}(${d.turns})`)
              .join(", ");
            lines.push(
              `${p.name} [${
                ROLE_LABEL[p.role] || p.role
              }] [${state}] HP ${fmtHp(p.hp, p.maxHp)} | ì²´ë ¥ ${effectiveStat(
                p,
                "vit"
              )} ê³µê²© ${effectiveStat(p, "atk")} ë°©ì–´ ${effectiveStat(
                p,
                "def"
              )} ë¯¼ì²© ${effectiveStat(p, "agi")} | ì¹˜ëª…íƒ€ìœ¨ ${critChance(p)}%` +
                (shields ? ` | SHIELD {${shields}}` : "") +
                (deb ? ` | DEBUFF {${deb}}` : "") +
                (dot ? ` | DOT {${dot}}` : "") +
                (p.ultUsed ? ` | ULT USED` : "")
            );
          }
          ps.textContent = lines.join("\n");
        }

        // round chips
        document.getElementById(
          "roundChip"
        ).textContent = `ROUND ${game.round}`;
        document.getElementById(
          "phaseChip"
        ).textContent = `PHASE: ${game.phase}`;

        // clear expired shields at render (based on round)
        for (const p of game.players) {
          p.shields = p.shields.filter((s) => s.expiresRound >= game.round);
        }
      }

      function renderPlayerActionCards() {
        const wrap = document.getElementById("playerActionCards");
        wrap.innerHTML = "";

        const aliveMonsters = game.monsters.filter((m) => m.alive);
        const alivePlayers = game.players.filter((p) => !p.down);

        for (const p of game.players) {
          const card = document.createElement("div");
          card.className = "card";

          const title = document.createElement("div");
          title.className = "row";
          title.style.justifyContent = "space-between";
          title.innerHTML = `
                  <div>
                    <h3 style="margin:0">${p.name} <small class="mono">(${
            p.role
          })</small></h3>
                    <small>${
                      p.down
                        ? `<span class="danger">DOWN</span> (ëŒ€ê¸° ${p.downCounter})`
                        : `HP ${p.hp}/${p.maxHp} | CRIT ${critChance(p)}%`
                    }</small>
                  </div>
                  <div class="rightMeta">
                    <span class="chip">ì•¡í‹°ë¸Œ: ${p.actives
                      .map((k) => skillName(p.role, k))
                      .join(" / ")}</span>
                    <span class="chip">ê¶ê·¹: ${skillName(p.role, p.ult)}</span>
                  </div>
                `;
          card.appendChild(title);

          const disabled = game.phase !== "PLAYER" || p.down;

          const actionKey = `action_${p.id}`;
          const skillKey = `skill_${p.id}`;
          const t1Key = `t1_${p.id}`;
          const t2Key = `t2_${p.id}`;
          const statKey = `stat_${p.id}`;

          card.innerHTML += `
                  <div class="actionRow">
                    <div>
                      <label>í–‰ë™</label>
                      <select id="${actionKey}" ${disabled ? "disabled" : ""}>
                        <option value="ATTACK">ê³µê²©</option>
                        <option value="DEFEND">ë°©ì–´</option>
                        <option value="ACTIVE">ì•¡í‹°ë¸Œ</option>
                        <option value="ULT">ê¶ê·¹ê¸°</option>
                      </select>
                    </div>
                    <div>
                      <label>ìŠ¤í‚¬(ì•¡í‹°ë¸Œ/ê¶ê·¹ê¸°)</label>
                      <select id="${skillKey}" ${
            disabled ? "disabled" : ""
          }></select>
                    </div>
                    <div>
                      <label>ëŒ€ìƒ 1</label>
                      <select id="${t1Key}" ${
            disabled ? "disabled" : ""
          }></select>
                    </div>
                    <div>
                      <label>ëŒ€ìƒ 2 / (í•„ìš” ì‹œ)</label>
                      <select id="${t2Key}" ${
            disabled ? "disabled" : ""
          }></select>
                    </div>
                    <div style="grid-column:1 / -1">
                      <label>ê²©ë ¤ ìŠ¤íƒ¯ ì„ íƒ(ì„œí¬í„° ê²©ë ¤ ì‹œ)</label>
                      <select id="${statKey}" ${disabled ? "disabled" : ""}>
                        <option value="atk">ê³µê²©</option>
                        <option value="def">ë°©ì–´</option>
                        <option value="agi">ë¯¼ì²©</option>
                        <option value="vit">ì²´ë ¥</option>
                      </select>
                    </div>
                  </div>
                `;

          wrap.appendChild(card);

          // fill skill dropdown based on action
          const actionSel = document.getElementById(actionKey);
          const skillSel = document.getElementById(skillKey);
          const t1Sel = document.getElementById(t1Key);
          const t2Sel = document.getElementById(t2Key);
          const statSel = document.getElementById(statKey);

          function fillTargets(mode) {
            // mode: based on selected skill target requirement
            const allies = game.players.map((x) => ({
              id: x.id,
              name: x.name,
              down: x.down,
            }));
            const enemies = game.monsters.map((x) => ({
              id: x.id,
              name: x.name,
              alive: x.alive,
            }));

            function setOptions(selectEl, options, placeholder) {
              selectEl.innerHTML = "";
              const ph = document.createElement("option");
              ph.value = "";
              ph.textContent = placeholder;
              selectEl.appendChild(ph);
              for (const o of options) {
                const opt = document.createElement("option");
                opt.value = o.id;
                opt.textContent = o.label;
                selectEl.appendChild(opt);
              }
            }

            const allyOpts = allies
              .filter((a) => !a.down)
              .map((a) => ({ id: a.id, label: `${a.name}` }));

            const allyAllOpts = allies.map((a) => ({
              id: a.id,
              label: `${a.name}${a.down ? " (DOWN)" : ""}`,
            }));

            const enemyOpts = enemies
              .filter((e) => e.alive)
              .map((e) => ({ id: e.id, label: `${e.name}` }));

            if (mode === "ENEMY1") {
              setOptions(t1Sel, enemyOpts, "ëª¬ìŠ¤í„° ì„ íƒ");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else if (mode === "ENEMY_ALL") {
              setOptions(t1Sel, [{ id: "ALL", label: "ì „ì²´ ëª¬ìŠ¤í„°" }], "ì „ì²´");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else if (mode === "ALLY1") {
              setOptions(t1Sel, allyOpts, "ì•„êµ° ì„ íƒ");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else if (mode === "ALLY2") {
              setOptions(t1Sel, allyOpts, "ì•„êµ°1");
              setOptions(t2Sel, allyOpts, "ì•„êµ°2");
            } else if (mode === "ALLY_ALL") {
              setOptions(t1Sel, [{ id: "ALL", label: "ì „ì²´ ì•„êµ°" }], "ì „ì²´");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else if (mode === "ALLY1_STAT") {
              setOptions(t1Sel, allyOpts, "ì•„êµ° ì„ íƒ");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else if (mode === "NONE") {
              setOptions(t1Sel, [], "ë¯¸ì‚¬ìš©");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            } else {
              // default
              setOptions(t1Sel, enemyOpts, "ëŒ€ìƒ ì„ íƒ");
              setOptions(t2Sel, [], "ë¯¸ì‚¬ìš©");
            }

            statSel.disabled =
              !(
                p.role === "SUPPORT" &&
                skillSel.value === "ENCOURAGE" &&
                actionSel.value === "ACTIVE"
              ) || disabled;
          }

          function fillSkills() {
            skillSel.innerHTML = "";
            const action = actionSel.value;

            const opt = (val, txt) => {
              const o = document.createElement("option");
              o.value = val;
              o.textContent = txt;
              return o;
            };

            if (action === "ACTIVE") {
              skillSel.appendChild(opt("", "ì•¡í‹°ë¸Œ ì„ íƒ"));
              for (const k of p.actives) {
                skillSel.appendChild(opt(k, skillName(p.role, k)));
              }
            } else if (action === "ULT") {
              skillSel.appendChild(
                opt(
                  p.ult,
                  `${skillName(p.role, p.ult)}${p.ultUsed ? " (ì‚¬ìš©ë¨)" : ""}`
                )
              );
            } else {
              skillSel.appendChild(opt("", "ìŠ¤í‚¬ ì—†ìŒ"));
            }

            // default targets based on selection
            const targetType = getSkillTargetType(
              p,
              actionSel.value,
              skillSel.value
            );
            fillTargets(targetType);
          }

          actionSel.addEventListener("change", () => fillSkills());
          skillSel.addEventListener("change", () => {
            const targetType = getSkillTargetType(
              p,
              actionSel.value,
              skillSel.value
            );
            fillTargets(targetType);
          });

          // initialize from saved action if exists
          fillSkills();

          const saved = game.actions.get(p.id);
          if (saved) {
            actionSel.value = saved.type;
            fillSkills();
            if (saved.type === "ACTIVE" || saved.type === "ULT") {
              if (saved.skillKey) skillSel.value = saved.skillKey;
            }
            if (saved.t1) t1Sel.value = saved.t1;
            if (saved.t2) t2Sel.value = saved.t2;
            if (saved.stat) statSel.value = saved.stat;
            // re-evaluate targets for stat selector
            const targetType = getSkillTargetType(
              p,
              actionSel.value,
              skillSel.value
            );
            fillTargets(targetType);
          }

          // save on any change
          const save = () => {
            const a = {
              type: actionSel.value,
              skillKey:
                actionSel.value === "ACTIVE" || actionSel.value === "ULT"
                  ? skillSel.value
                  : null,
              t1: t1Sel.value || null,
              t2: t2Sel.value || null,
              stat: statSel.value || "atk",
            };
            game.actions.set(p.id, a);
            updateReadyChip();
          };

          [actionSel, skillSel, t1Sel, t2Sel, statSel].forEach((el) =>
            el.addEventListener("change", save)
          );
          updateReadyChip();
        }
      }

      function updateReadyChip() {
        const total = game.players.filter((p) => !p.down).length;
        let ready = 0;
        for (const p of game.players) {
          if (p.down) continue;
          const a = game.actions.get(p.id);
          if (!a) continue;
          // minimal validation: ATTACK/DEFEND always ready; ACTIVE needs skillKey; ULT ready even if used (will fail in resolve)
          if (a.type === "ATTACK" || a.type === "DEFEND") ready++;
          else if (a.type === "ACTIVE") {
            if (a.skillKey) ready++;
          } else if (a.type === "ULT") {
            ready++;
          }
        }
        document.getElementById(
          "readyChip"
        ).textContent = `READY: ${ready}/${total}`;
      }

      function skillName(role, key) {
        const pool = [...SKILLS[role].active, ...SKILLS[role].ult];
        const s = pool.find((x) => x.key === key);
        return s ? s.name : key;
      }

      function getSkillTargetType(player, actionType, skillKey) {
        if (actionType === "ACTIVE") {
          const s = SKILLS[player.role].active.find((x) => x.key === skillKey);
          return s ? s.target : "NONE";
        }
        if (actionType === "ULT") {
          const s = SKILLS[player.role].ult.find((x) => x.key === skillKey);
          return s ? s.target : "NONE";
        }
        // attack defaults to ENEMY1
        if (actionType === "ATTACK") return "ENEMY1";
        return "NONE";
      }

      /* =========================
               Monster Intent
            ========================= */
      function chooseMonsterIntent() {
        const aliveMonsters = game.monsters.filter((m) => m.alive);
        const alivePlayers = game.players.filter((p) => !p.down);

        if (aliveMonsters.length === 0) return null;
        if (alivePlayers.length === 0) return null;

        // choose a monster to act this round (if multiple, all act; intent shows aggregated)
        // We'll create per-monster intent list, but show summary text.
        const intents = [];

        for (const m of aliveMonsters) {
          const r = Math.random();
          if (r < 0.25) {
            // ë‹¨ì¼ ê³µê²©
            const t =
              alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            intents.push({
              monsterId: m.id,
              type: "SINGLE",
              targetIds: [t.id],
              text: `${m.name}ëŠ” ${t.name}ë¥¼ ë…¸ë ¤ë³´ê³  ìˆë‹¤. (ë‹¨ì¼ ê³µê²©)`,
            });
          } else if (r < 0.5) {
            // ê´‘ì—­ê³µê²© 1~3ì¸
            const n = Math.min(
              alivePlayers.length,
              Math.floor(Math.random() * 3) + 1
            );
            const shuffled = alivePlayers
              .slice()
              .sort(() => Math.random() - 0.5);
            const targets = shuffled.slice(0, n);
            // ğŸ”¥ ì´ ì¤„ì´ ì—†ì–´ì„œ í„°ì§„ ê²ƒ
            const targetNames = targets.map((t) => t.name).join(", ");

            intents.push({
              monsterId: m.id,
              type: "AOE",
              targetIds: targets.map((x) => x.id),
              text: `${m.name}ëŠ” ${targetNames}ë¥¼ í–¥í•´ ëˆˆì„ êµ´ë¦¬ê³  ìˆë‹¤. (ê´‘ì—­ ${n}ì¸)`,
            });
          } else if (r < 0.75) {
            // bleeding 1~8
            const n = Math.min(
              alivePlayers.length,
              Math.floor(Math.random() * 8) + 1
            );
            const shuffled = alivePlayers
              .slice()
              .sort(() => Math.random() - 0.5);
            const targets = shuffled.slice(0, n);
            // ğŸ”¥ ì´ê²ƒë„ ë™ì¼
            const targetNames = targets.map((t) => t.name).join(", ");
            intents.push({
              monsterId: m.id,
              type: "BLEED",
              targetIds: targets.map((x) => x.id),
              text: `${targetNames}ì„(ë¥¼) ë…¸ë ¤ë³´ê³  ìˆëŠ” ${m.name}ì˜ ê³µê²©ì€ ì¶œí˜ˆì„ ìœ ë°œí•  ê²ƒë§Œ ê°™ë‹¤. (ì¶œí˜ˆ ${n}ì¸)`,
            });
          } else {
            // self buff
            const stats = ["atk", "def", "agi", "vit"];
            const s = stats[Math.floor(Math.random() * stats.length)];
            intents.push({
              monsterId: m.id,
              type: "BUFF",
              buffStat: s,
              text: `${
                m.name
              }ëŠ” ë°©ì–´íƒœì„¸ë¥¼ ì·¨í•˜ë ¤ í•œë‹¤. (ìê°€ë²„í”„: ${s.toUpperCase()})`,
            });
          }
        }

        return intents;
      }

      /* =========================
               Round Flow
            ========================= */
      function startRound() {
        if (game.players.length === 0) {
          log("âš ï¸ í”Œë ˆì´ì–´ë¥¼ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”.");
          return;
        }
        if (game.monsters.length === 0) {
          log("âš ï¸ ëª¬ìŠ¤í„°ë¥¼ ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”.");
          return;
        }
        if (game.phase !== "HINT" && game.phase !== "RESOLVE") {
          log(
            "âš ï¸ í˜„ì¬ ë¼ìš´ë“œê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. (ë¼ìš´ë“œ í•´ì„ í›„ ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘)"
          );
          return;
        }

        // round start: revive counters, apply pending buffs, tick DOT
        log(`\n=== ROUND ${game.round} START ===`);
        for (const p of game.players) {
          reviveIfReady(p);
        }
        tickDots();

        // clear per-round flags
        for (const p of game.players) {
          p._defendBonus = 0;
          p.minHpFloor = false;
          p.tankingAll = false;
          p.redirect = null; // reset; will be set by skills
        }
        for (const m of game.monsters) {
          // none for now
        }

        // generate monster intent(s)
        game.monsterIntents = chooseMonsterIntent();
        if (!game.monsterIntents) {
          log("ì „íˆ¬ë¥¼ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ëŒ€ìƒ ì—†ìŒ)");
          return;
        }

        const hintText = game.monsterIntents
          .map((x) => "- " + x.text)
          .join("\n");
        document.getElementById("hintBox").textContent = hintText;
        log(`ëª¬ìŠ¤í„° í–‰ë™ ì•”ì‹œ:\n${hintText}`);

        // phase to PLAYER
        game.phase = "PLAYER";
        renderPlayerActionCards();
        renderStates();
      }

      function resolveRound() {
        if (game.phase !== "PLAYER") {
          log("âš ï¸ ë¨¼ì € 'ë¼ìš´ë“œ ì‹œì‘(ì•”ì‹œ)' í›„, ì¤‘ì•™ì—ì„œ í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”.");
          return;
        }

        const alivePlayers = game.players.filter((p) => !p.down);
        if (alivePlayers.length === 0) {
          log("âš ï¸ í–‰ë™ ê°€ëŠ¥í•œ í”Œë ˆì´ì–´ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        // validation: ensure actions exist
        for (const p of alivePlayers) {
          if (!game.actions.get(p.id)) {
            game.actions.set(p.id, {
              type: "ATTACK",
              skillKey: null,
              t1: null,
              t2: null,
              stat: "atk",
            });
          }
        }

        game.phase = "RESOLVE";
        renderStates();

        // 1) Apply player DEFEND bonuses first (so monster damage mitigation works)
        for (const p of alivePlayers) {
          const a = game.actions.get(p.id);
          if (a?.type === "DEFEND") {
            const bonus = finalStat(p, "def");
            p._defendBonus = bonus;
            log(`ğŸ›¡ï¸ ${p.name} ë°©ì–´: ì¶”ê°€ ê²½ê° ${bonus}`);
          }
        }

        // 2) Resolve PLAYER actions (in simple order; you can change to AGI ordering)
        log(`--- í”Œë ˆì´ì–´ í„´ (${alivePlayers.length}ì¸) ---`);
        for (const p of alivePlayers) {
          const a = game.actions.get(p.id);
          resolvePlayerAction(p, a);
        }

        // 3) Resolve MONSTER actions
        log(`--- ëª¬ìŠ¤í„° í„´ ---`);
        resolveMonsterActions();

        // 4) End of round: cleanup, decay debuffs, check downs, summary
        for (const p of game.players) {
          setDownIfNeeded(p);
        }
        decayDebuffsEndRound();

        log(`--- ìµœì¢… í•©ì‚° ---`);
        summarizeRound();

        // prepare next
        game.round += 1;
        game.phase = "HINT";
        game.actions.clear();
        game.monsterIntents = null;

        renderPlayerActionCards();
        renderStates();
      }

      function summarizeRound() {
        // brief summary in log + states already show detailed
        const aliveM = game.monsters.filter((m) => m.alive).length;
        const downP = game.players.filter((p) => p.down).length;
        log(
          `ê²°ê³¼: ëª¬ìŠ¤í„° ìƒì¡´ ${aliveM}/${game.monsters.length}, í”Œë ˆì´ì–´ ë‹¤ìš´ ${downP}/${game.players.length}`
        );
      }

      /* =========================
               Player Action Resolution
            ========================= */
      function resolvePlayerAction(p, a) {
        if (!a)
          a = {
            type: "ATTACK",
            skillKey: null,
            t1: null,
            t2: null,
            stat: "atk",
          };

        if (a.type === "ATTACK") {
          const target = pickMonsterById(a.t1) || firstAliveMonster();
          if (!target) {
            log(`âš ï¸ ${p.name} ê³µê²© ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
            return;
          }
          doAttack(p, target, {
            mult: 1.0,
            ignoreDefense: false,
            label: "ê¸°ë³¸ê³µê²©",
          });
          return;
        }

        if (a.type === "DEFEND") {
          // already applied bonus; nothing else
          return;
        }

        if (a.type === "ACTIVE") {
          const key = a.skillKey;
          if (!key) {
            log(`âš ï¸ ${p.name} ì•¡í‹°ë¸Œ ë¯¸ì„ íƒ â†’ ê¸°ë³¸ê³µê²©ìœ¼ë¡œ ëŒ€ì²´`);
            const target = firstAliveMonster();
            if (target) doAttack(p, target, { mult: 1.0, label: "ê¸°ë³¸ê³µê²©" });
            return;
          }
          // consecutive active check
          if (p.lastActiveKey === key) {
            log(
              `âš ï¸ ${p.name} ì•¡í‹°ë¸Œ ì—°ì† ì‚¬ìš© ë¶ˆê°€(${skillName(
                p.role,
                key
              )}) â†’ ê¸°ë³¸ê³µê²©ìœ¼ë¡œ ëŒ€ì²´`
            );
            const target = firstAliveMonster();
            if (target) doAttack(p, target, { mult: 1.0, label: "ê¸°ë³¸ê³µê²©" });
            return;
          }
          resolveSkill(p, "ACTIVE", key, a);
          p.lastActiveKey = key;
          return;
        }

        if (a.type === "ULT") {
          const key = p.ult;
          if (p.ultUsed) {
            log(
              `âš ï¸ ${p.name} ê¶ê·¹ê¸°(${skillName(
                p.role,
                key
              )})ëŠ” ì´ë¯¸ ì‚¬ìš©ë¨ â†’ ê¸°ë³¸ê³µê²©ìœ¼ë¡œ ëŒ€ì²´`
            );
            const target = firstAliveMonster();
            if (target) doAttack(p, target, { mult: 1.0, label: "ê¸°ë³¸ê³µê²©" });
            return;
          }
          resolveSkill(p, "ULT", key, a);
          p.ultUsed = true;
          return;
        }
      }

      function doAttack(
        attacker,
        target,
        {
          mult = 1.0,
          ignoreDefense = false,
          label = "ê³µê²©",
          diceTwice = false,
          diceSum = false,
          fixed = null,
        } = {}
      ) {
        if (target.type === "MONSTER" && !target.alive) {
          log(`âš ï¸ ${attacker.name} ${label}: ëŒ€ìƒ ${target.name}ì€ ì´ë¯¸ ì‚¬ë§`);
          return;
        }
        let raw = 0;

        if (fixed !== null) {
          raw = fixed;
        } else {
          if (diceTwice) {
            const atk = effectiveStat(attacker, "atk");
            const r1 = d6(),
              r2 = d6();
            const base = atk * r1 + atk * r2;
            raw = base;
          } else {
            raw = baseAttackDamage(attacker);
          }
        }

        raw = raw * mult;

        // crit
        const c = pct(critChance(attacker));
        if (c && fixed === null) {
          // fixed damage does not crit
          raw = raw * 2;
          log(`âœ¨ CRIT! ${attacker.name} (${label})`);
        }

        raw = Math.floor(raw);

        const res = applyDamage(target, raw, { ignoreDefense });
        log(
          `ğŸ—¡ï¸ ${attacker.name} â†’ ${target.name} (${label}) í”¼í•´ ${raw} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
        );

        // if attacker is tank with ENDURE active, we count damage taken not dealt; handled elsewhere.
      }

      /* =========================
               Skills
            ========================= */
      function resolveSkill(p, type, key, a) {
        // Pre-checks: targets existence
        const role = p.role;

        if (role === "TANK") {
          if (type === "ULT" && key === "UNYIELDING") {
            // all incoming damage + debuffs -> tank; hp floor 1
            p.tankingAll = true;
            p.minHpFloor = true;
            log(
              `ğŸ›¡ï¸ ${p.name} ê¶ê·¹ê¸° ë°œë™: ë¶ˆêµ´ (1í„´ ì „ì²´ ëŒ€ì‹  ë°›ìŒ, HP 1 ë¯¸ë§Œ ë¶ˆê°€)`
            );
            return;
          }
          if (type === "ULT" && key === "DEVOTION") {
            const dmg = finalStat(p, "def") * 2;
            log(
              `ğŸ’¥ ${p.name} ê¶ê·¹ê¸° ë°œë™: í—Œì‹  (ìì‹  HP ì „ë¶€ ì†Œëª¨ í›„ ì  ì „ì²´ ${dmg} ê³µê²©)`
            );
            // attack first, then drop
            for (const m of game.monsters.filter((m) => m.alive)) {
              const res = applyDamage(m, dmg, { ignoreDefense: false });
              log(
                `   â†³ ${m.name} í”¼í•´ ${dmg} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
              );
            }
            p.hp = 0;
            setDownIfNeeded(p);
            return;
          }

          if (type === "ACTIVE" && key === "GUARD") {
            const t1 = pickPlayerById(a.t1);
            const t2 = pickPlayerById(a.t2);
            const targets = [t1, t2].filter(
              (x) => x && !x.down && x.id !== p.id
            );
            if (targets.length === 0) {
              log(`âš ï¸ ${p.name} í˜¸ìœ„ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ â†’ ê¸°ë³¸ê³µê²©`);
              const m = firstAliveMonster();
              if (m) doAttack(p, m, { label: "ê¸°ë³¸ê³µê²©" });
              return;
            }
            const fDef = finalStat(p, "def");
            const shield = Math.floor(fDef * 0.5);
            for (const t of targets) {
              // no stacking same active: just add shield but you can choose to overwrite; here we add.
              t.shields.push({ value: shield, expiresRound: game.round });
              log(
                `ğŸ›¡ï¸ ${p.name} í˜¸ìœ„ â†’ ${t.name} ë³´í˜¸ë§‰ ${shield} (R${game.round}ê¹Œì§€)`
              );
            }
            return;
          }

          if (type === "ACTIVE" && key === "PROTECT") {
            const ally = pickPlayerById(a.t1);
            if (!ally || ally.down || ally.id === p.id) {
              log(`âš ï¸ ${p.name} ìˆ˜í˜¸ ì‹¤íŒ¨: ìœ íš¨ ì•„êµ° ì—†ìŒ â†’ ê¸°ë³¸ê³µê²©`);
              const m = firstAliveMonster();
              if (m) doAttack(p, m, { label: "ê¸°ë³¸ê³µê²©" });
              return;
            }

            // "ì´ë²ˆ í„´"ë§Œ ìœ íš¨í•œ í’€ ë¦¬ë‹¤ì´ë ‰íŠ¸
            ally.redirect = {
              tankId: p.id,
              mode: "FULL",
              defMult: 1.3,
              expiresRound: game.round, // ì„ íƒ: ë¼ìš´ë“œ ì¢…ë£Œ ì‹œ ì •ë¦¬í•  ë•Œ ì“°ê¸° ì¢‹ìŒ
            };

            log(
              `ğŸ›¡ï¸ ${p.name} ìˆ˜í˜¸ â†’ ${ally.name} : ì´ë²ˆ í„´ ëª¬ìŠ¤í„° ê³µê²©/íš¨ê³¼ë¥¼ ${p.name}ì´ ëŒ€ì‹  ë°›ìŒ (ë°©ì–´ 1.3ë°°)`
            );
            return;
          }

          if (type === "ACTIVE" && key === "ENDURE") {
            p.endure = { accum: 0, turnsLeft: 3 };
            log(
              `ğŸ§± ${p.name} ì¸ë‚´ ì‹œì‘: 3í„´ ëˆ„ì  í”¼í•´ì˜ 0.5 ë°˜ì‚¬(ëœë¤ ëª¬ìŠ¤í„°)`
            );
            return;
          }

          if (type === "ACTIVE" && key === "FIGHTING_SPIRIT") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} íˆ¬í˜¼ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ â†’ ê¸°ë³¸ê³µê²©`);
              const mm = firstAliveMonster();
              if (mm) doAttack(p, mm, { label: "ê¸°ë³¸ê³µê²©" });
              return;
            }
            p.fightingSpirit = { targetId: m.id, turnsLeft: 2 };
            log(
              `ğŸ”¥ ${p.name} íˆ¬í˜¼ ì‹œì‘: 2í„´ê°„ DEF -5, ë§¤ í„´ ${m.name}ì—ê²Œ ê³ ì • 100`
            );
            // immediate tick this turn
            const target = pickMonsterById(p.fightingSpirit.targetId);
            if (target && target.alive) {
              doAttack(p, target, {
                fixed: 100,
                label: "íˆ¬í˜¼(ê³ ì •)",
                ignoreDefense: false,
              });
            }
            return;
          }
        }

        if (role === "DPS") {
          if (type === "ULT" && key === "MERCY") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} ìë¹„ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            // attack dice twice sum then *2
            doAttack(p, m, { diceTwice: true, mult: 2.0, label: "ìë¹„" });
            return;
          }
          if (type === "ULT" && key === "CHARGE") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} ëŒê²© ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            doAttack(p, m, {
              mult: 1.0,
              ignoreDefense: true,
              label: "ëŒê²©(ë°©ì–´ë¬´ì‹œ)",
            });
            return;
          }

          if (type === "ACTIVE" && key === "MADNESS") {
            p.pendingAtkPlusNext += 2;
            log(
              `ğŸ˜ˆ ${p.name} ê´‘ê¸°: ë‹¤ìŒ í„´ ê³µê²© +2 (ëˆ„ì  ${p.pendingAtkPlusNext})`
            );
            return;
          }

          if (type === "ACTIVE" && key === "OBSESSION") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} ì§‘ë… ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const dotVal = Math.floor(baseAttackDamage(p) * 0.5);
            addDot(m, {
              type: "OBSESSION",
              value: dotVal,
              turns: 3,
              sourceId: p.id,
            });
            log(`ğŸ©¸ ${p.name} ì§‘ë… â†’ ${m.name} DOT ${dotVal} x3í„´ (ì¤‘ì²© ê°€ëŠ¥)`);
            return;
          }

          if (type === "ACTIVE" && key === "BLOODFIGHT") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} í˜ˆíˆ¬ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const cost = Math.ceil(p.hp * 0.5);
            p.hp = Math.max(0, p.hp - cost);
            log(`ğŸ©¸ ${p.name} í˜ˆíˆ¬: HP ${cost} ì†Œëª¨`);
            setDownIfNeeded(p);
            if (p.down) {
              log(`âš ï¸ ${p.name} í˜ˆíˆ¬ í›„ ë‹¤ìš´ë˜ì–´ ê³µê²© ë¶ˆë°œ`);
              return;
            }
            doAttack(p, m, { mult: 1.5, label: "í˜ˆíˆ¬" });
            return;
          }

          if (type === "ACTIVE" && key === "MASSACRE") {
            const fAtk = finalStat(p, "atk");
            const dmg = Math.floor(fAtk * 0.8);
            log(`âš”ï¸ ${p.name} ì°¸ì‚´: ì  ì „ì²´ ${dmg} ê³µê²©`);
            for (const mm of game.monsters.filter((x) => x.alive)) {
              const res = applyDamage(mm, dmg, { ignoreDefense: false });
              log(
                `   â†³ ${mm.name} í”¼í•´ ${dmg} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
              );
            }
            return;
          }
        }

        if (role === "SUPPORT") {
          if (type === "ULT" && key === "REINCARNATION") {
            const ally = pickPlayerById(a.t1);
            if (!ally) {
              log(`âš ï¸ ${p.name} ìœ¤íšŒ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            ally.ultUsed = false;
            log(`ğŸ”„ ${p.name} ìœ¤íšŒ â†’ ${ally.name} ê¶ê·¹ê¸° ì‚¬ìš© ê°€ëŠ¥ìœ¼ë¡œ ì´ˆê¸°í™”`);
            return;
          }
          if (type === "ULT" && key === "REST") {
            log(`ğŸŒ¿ ${p.name} ì•ˆì‹: ì „ì²´ íšŒë³µ + ë‹¤ìš´ ëŒ€ê¸° ì œê±°`);
            for (const ally of game.players) {
              // revive downed immediately to full
              ally.down = false;
              ally.downCounter = 0;
              ally.hp = ally.maxHp;
            }
            return;
          }

          if (type === "ACTIVE" && key === "REVIVE") {
            const ally = pickPlayerById(a.t1);
            if (!ally) {
              log(`âš ï¸ ${p.name} íšŒìƒ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const amount = finalStat(p, "agi");
            const healed = heal(ally, amount);
            log(`ğŸ’š ${p.name} íšŒìƒ â†’ ${ally.name} íšŒë³µ ${healed}`);
            return;
          }

          if (type === "ACTIVE" && key === "BLESS") {
            const a1 = pickPlayerById(a.t1);
            const a2 = pickPlayerById(a.t2);
            const targets = [a1, a2].filter((x) => x);
            if (targets.length === 0) {
              log(`âš ï¸ ${p.name} ê°€í˜¸ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const amount = Math.floor(finalStat(p, "agi") * 0.5);
            for (const t of targets) {
              const healed = heal(t, amount);
              log(`ğŸ’š ${p.name} ê°€í˜¸ â†’ ${t.name} íšŒë³µ ${healed}`);
            }
            return;
          }

          if (type === "ACTIVE" && key === "ENCOURAGE") {
            const ally = pickPlayerById(a.t1);
            if (!ally) {
              log(`âš ï¸ ${p.name} ê²©ë ¤ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const stat = a.stat || "atk";
            const plusKey = stat + "Plus";
            ally.temp[plusKey] += 2;
            // duration 1 turn -> add as debuff-like marker to remove end of round
            addDebuff(ally, {
              type: "ENCOURAGE_" + stat.toUpperCase(),
              value: 2,
              turns: 1,
              sourceId: p.id,
            });
            log(
              `ğŸ“£ ${p.name} ê²©ë ¤ â†’ ${ally.name} ${stat.toUpperCase()} +2 (1í„´)`
            );
            return;
          }

          if (type === "ACTIVE" && key === "PURIFY") {
            const a1 = pickPlayerById(a.t1);
            const a2 = pickPlayerById(a.t2);
            const targets = [a1, a2].filter((x) => x);
            if (targets.length === 0) {
              log(`âš ï¸ ${p.name} ì •í™” ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            for (const t of targets) {
              clearDebuffs(t);
              t.dots = [];
              log(`âœ¨ ${p.name} ì •í™” â†’ ${t.name} ë””ë²„í”„/DOT í•´ì œ`);
            }
            return;
          }

          if (type === "ACTIVE" && key === "PENANCE") {
            const m = pickMonsterById(a.t1) || firstAliveMonster();
            if (!m) {
              log(`âš ï¸ ${p.name} ì°¸íšŒ ì‹¤íŒ¨: ëŒ€ìƒ ì—†ìŒ`);
              return;
            }
            const val = Math.floor(finalStat(p, "agi") * 0.5);
            const ok = addDebuff(m, {
              type: "PENANCE",
              value: val,
              turns: 1,
              sourceId: p.id,
            });
            if (ok) {
              log(`ğŸ•¯ï¸ ${p.name} ì°¸íšŒ â†’ ${m.name} ê³µê²© -${val} (1í„´, ì¤‘ì²©ë¶ˆê°€)`);
            } else {
              log(`âš ï¸ ${p.name} ì°¸íšŒ ì‹¤íŒ¨: ì´ë¯¸ ì ìš© ì¤‘ (ì¤‘ì²©ë¶ˆê°€)`);
            }
            return;
          }
        }

        // fallback
        log(`âš ï¸ ${p.name} ìŠ¤í‚¬ ì²˜ë¦¬ ë¯¸êµ¬í˜„(${key}) â†’ ê¸°ë³¸ê³µê²©`);
        const target = firstAliveMonster();
        if (target) doAttack(p, target, { label: "ê¸°ë³¸ê³µê²©" });
      }

      /* =========================
               Monster Action Resolution
            ========================= */
      function resolveMonsterActions() {
        const intents = game.monsterIntents || [];
        for (const intent of intents) {
          const m = game.monsters.find((x) => x.id === intent.monsterId);
          if (!m || !m.alive) continue;

          // apply buff intent
          if (intent.type === "BUFF") {
            const inc = d5();
            const stat = intent.buffStat;

            m.buffs.push({
              stat,
              value: inc,
              turns: 2,
            });

            log(`â¬†ï¸ ${m.name} ìê°€ë²„í”„: ${stat.toUpperCase()} +${inc} (2í„´)`);
            continue;
          }

          // compute base damage scale
          // single: atk*1d6*2
          // aoe: atk*1d6 (ê° ëŒ€ìƒ)
          // bleed: apply DOT 1d10 x3í„´ (ê° ëŒ€ìƒ)
          const targets = (intent.targetIds || [])
            .map((id) => pickPlayerById(id))
            .filter((x) => x);

          if (intent.type === "SINGLE") {
            const t = targets[0] || randomAlivePlayer();
            if (!t) {
              continue;
            }
            const atk = effectiveStat(m, "atk");
            const raw = applyDebuffsToMonsterAttack(m, atk * d6() * 2);
            dealMonsterDamage(m, t, raw, { label: "ë‹¨ì¼ê³µê²©" });
            continue;
          }

          if (intent.type === "AOE") {
            const targets = intent.targetIds
              .map((id) => game.players.find((p) => p.id === id))
              .filter(Boolean);

            for (const t of targets) {
              if (t.down) continue;
              const atk = effectiveStat(m, "atk");
              const raw = applyDebuffsToMonsterAttack(m, atk * d6());
              dealMonsterDamage(m, t, raw, { label: "ê´‘ì—­ê³µê²©" });
            }
            continue;
          }

          if (intent.type === "BLEED") {
            const targets = intent.targetIds
              .map((id) => game.players.find((p) => p.id === id))
              .filter(Boolean);

            for (const t of targets) {
              if (t.down) continue;
              const val = d10();
              addDot(t, {
                type: "BLEED",
                value: val,
                turns: 3,
                sourceId: m.id,
              });
              log(
                `ğŸ©¸ ${m.name}ì˜ ê³µê²©ìœ¼ë¡œ ${t.name}ì—ê²Œ ì¶œí˜ˆ ë°œìƒ! ${val} ë°ë¯¸ì§€ 3í„´`
              );
            }
            continue;
          }
        }

        // tank passive ENDURE tick down & reflect if completed
        for (const p of game.players) {
          if (p.endure) {
            p.endure.turnsLeft -= 1;
            if (p.endure.turnsLeft <= 0) {
              const dmg = Math.floor(p.endure.accum * 0.5);
              const target = firstAliveMonster();
              if (target && dmg > 0) {
                const res = applyDamage(target, dmg, { ignoreDefense: false });
                log(
                  `ğŸ§± ${p.name} ì¸ë‚´ ë°˜ì‚¬: ${target.name} í”¼í•´ ${dmg} (ì‹¤ì œ ${res.dealt})`
                );
              } else {
                log(`ğŸ§± ${p.name} ì¸ë‚´ ì¢…ë£Œ: ë°˜ì‚¬ í”¼í•´ ì—†ìŒ`);
              }
              p.endure = null;
            }
          }
        }

        // fighting spirit second tick if active (we already ticked when cast, so here tick if still active for next turns)
        for (const p of game.players) {
          if (p.fightingSpirit) {
            p.fightingSpirit.turnsLeft -= 1;
            if (p.fightingSpirit.turnsLeft > 0) {
              const target = pickMonsterById(p.fightingSpirit.targetId);
              if (target && target.alive && !p.down) {
                doAttack(p, target, {
                  fixed: 100,
                  label: "íˆ¬í˜¼(ê³ ì •)",
                  ignoreDefense: false,
                });
              }
            } else {
              log(`ğŸ”¥ ${p.name} íˆ¬í˜¼ ì¢…ë£Œ`);
              p.fightingSpirit = null;
            }
          }
        }
      }

      function dealMonsterDamage(monster, target, raw, { label = "" } = {}) {
        // 1) ë¶ˆêµ´(ì „ì²´ ëŒ€ì‹ ë§ê¸°)
        const tankAll = game.players.find((p) => p.tankingAll && !p.down);
        if (tankAll) {
          const res = applyDamage(tankAll, raw, {
            ignoreDefense: false,
            allowFloor: tankAll.minHpFloor,
            defMult: 1.0,
          });

          log(
            `ğŸ‘¹ ${monster.name} â†’ ${tankAll.name} (${label}) í”¼í•´ ${raw} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
          );

          if (tankAll.endure) tankAll.endure.accum += res.dealt;
          setDownIfNeeded(tankAll);
          return;
        }

        // 2) ìˆ˜í˜¸(FULL redirect)
        if (
          target &&
          !target.down &&
          target.redirect &&
          target.redirect.mode === "FULL"
        ) {
          const tank = pickPlayerById(target.redirect.tankId);
          if (tank && !tank.down) {
            const defMult = target.redirect.defMult ?? 1.3;

            const res = applyDamage(tank, raw, {
              ignoreDefense: false,
              allowFloor: tank.minHpFloor,
              defMult, // â† ìˆ˜í˜¸ì˜ í•µì‹¬: ë°©ì–´ 1.3ë°°
            });

            log(
              `ğŸ‘¹ ${monster.name} â†’ ${target.name} (${label}) í”¼í•´ ${raw} (ìˆ˜í˜¸: ${tank.name}ì´ ëŒ€ì‹  ë°›ìŒ, ë°©ì–´ ${defMult}ë°°) ` +
                `(ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
            );

            if (tank.endure) tank.endure.accum += res.dealt;
            setDownIfNeeded(tank);
            return; // â˜… í”¼í•´ ëŒ€ìƒì(target)ëŠ” ì—¬ê¸°ì„œ ì•„ë¬´ í”¼í•´ë„ ë°›ì§€ ì•ŠìŒ
          }
          // íƒ±ì»¤ê°€ ì—†ê±°ë‚˜ ë‹¤ìš´ì´ë©´ fallbackìœ¼ë¡œ ì›ë˜ ëŒ€ìƒì´ ë§ìŒ
        }

        // 3) ê¸°ë³¸: ì›ë˜ ëŒ€ìƒì´ ë§ìŒ
        const res = applyDamage(target, raw, {
          ignoreDefense: false,
          allowFloor: target.minHpFloor,
          defMult: 1.0,
        });

        log(
          `ğŸ‘¹ ${monster.name} â†’ ${target.name} (${label}) í”¼í•´ ${raw} (ì‹¤ì œ ${res.dealt}, ë³´í˜¸ë§‰ ${res.absorbed}, ê²½ê° ${res.mitigated})`
        );

        if (target.endure) target.endure.accum += res.dealt;
        setDownIfNeeded(target);
      }

      /* =========================
               Target helpers
            ========================= */
      function pickPlayerById(id) {
        return game.players.find((p) => p.id === id);
      }
      function pickMonsterById(id) {
        return game.monsters.find((m) => m.id === id);
      }
      function firstAliveMonster() {
        return game.monsters.find((m) => m.alive);
      }
      function randomAlivePlayer() {
        const alive = game.players.filter((p) => !p.down);
        if (alive.length === 0) return null;
        return alive[Math.floor(Math.random() * alive.length)];
      }

      /* =========================
               Character Creation UI
            ========================= */
      function populateSkillSelectors() {
        const roleSel = document.getElementById("pRole");
        const a1 = document.getElementById("pActive1");
        const a2 = document.getElementById("pActive2");
        const u = document.getElementById("pUlt");

        function fill() {
          const role = roleSel.value;
          a1.innerHTML = "";
          a2.innerHTML = "";
          u.innerHTML = "";

          for (const s of SKILLS[role].active) {
            const o1 = document.createElement("option");
            o1.value = s.key;
            o1.textContent = `${s.name} - ${s.desc}`;
            const o2 = o1.cloneNode(true);
            a1.appendChild(o1);
            a2.appendChild(o2);
          }
          for (const s of SKILLS[role].ult) {
            const ou = document.createElement("option");
            ou.value = s.key;
            ou.textContent = `${s.name} - ${s.desc}`;
            u.appendChild(ou);
          }
        }
        roleSel.addEventListener("change", fill);
        fill();
      }

      function updateSumHint() {
        const vit = +document.getElementById("pVit").value;
        const atk = +document.getElementById("pAtk").value;
        const def = +document.getElementById("pDef").value;
        const agi = +document.getElementById("pAgi").value;
        const sum = vit + atk + def + agi;
        const el = document.getElementById("sumHint");
        if (sum === 28) {
          el.textContent = `ìŠ¤íƒ¯ ì´í•© ${sum} (OK)`;
          el.className = "ok";
        } else {
          el.textContent = `ìŠ¤íƒ¯ ì´í•© ${sum} (íŒ¨ì‹œë¸Œ í¬í•¨ 28)`;
          el.className = "warn";
        }
      }

      /* =========================
               Buff cleanup (ENCOURAGE)
               We used debuff markers ENCOURAGE_* to remove their stat+2 at end of round.
               This is handled by decayDebuffsEndRound, but we must also revert temp stat.
            ========================= */
      const _oldDecay = decayDebuffsEndRound;
      decayDebuffsEndRound = function () {
        // Before decrement removal, find expiring ENCOURAGE debuffs and revert
        for (const p of game.players) {
          for (const d of p.debuffs) {
            if (d.type.startsWith("ENCOURAGE_") && d.turns === 1) {
              const stat = d.type.replace("ENCOURAGE_", "").toLowerCase(); // atk/def/agi/vit
              const plusKey = stat + "Plus";
              p.temp[plusKey] = Math.max(0, (p.temp[plusKey] || 0) - 2);
              log(`â³ ê²©ë ¤ ì¢…ë£Œ: ${p.name} ${stat.toUpperCase()} -2`);
            }
          }
        }
        _oldDecay();
      };

      /* =========================
               Wire UI Events
            ========================= */
      populateSkillSelectors();

      ["pVit", "pAtk", "pDef", "pAgi"].forEach((id) => {
        document.getElementById(id).addEventListener("input", updateSumHint);
      });
      updateSumHint();

      document.getElementById("addPlayerBtn").addEventListener("click", () => {
        if (game.players.length >= 8) {
          log("âš ï¸ í”Œë ˆì´ì–´ëŠ” ìµœëŒ€ 8ëª…ì…ë‹ˆë‹¤.");
          return;
        }
        const name =
          (document.getElementById("pName").value || "").trim() ||
          `Player${game.players.length + 1}`;
        const role = document.getElementById("pRole").value;
        const vit = clamp(+document.getElementById("pVit").value, 1, 12);
        const atk = clamp(+document.getElementById("pAtk").value, 1, 12);
        const def = clamp(+document.getElementById("pDef").value, 1, 12);
        const agi = clamp(+document.getElementById("pAgi").value, 1, 12);

        const a1 = document.getElementById("pActive1").value;
        const a2 = document.getElementById("pActive2").value;
        const ult = document.getElementById("pUlt").value;

        if (a1 === a2) {
          log(
            "âš ï¸ ì•¡í‹°ë¸Œ 2ê°œëŠ” ì„œë¡œ ë‹¤ë¥¸ ìŠ¤í‚¬ì„ ì„ íƒí•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤. (ë™ì¼ ì„ íƒë„ ì¼ë‹¨ í—ˆìš©)"
          );
        }

        const p = makePlayer({
          name,
          role,
          vit,
          atk,
          def,
          agi,
          actives: [a1, a2],
          ult,
        });
        game.players.push(p);
        log(`+ í”Œë ˆì´ì–´ ì¶”ê°€: ${p.name} (${p.role}) HP ${p.maxHp}`);
        renderPlayerActionCards();
        renderStates();
      });

      document
        .getElementById("clearPlayersBtn")
        .addEventListener("click", () => {
          game.players = [];
          game.actions.clear();
          log("í”Œë ˆì´ì–´ ì´ˆê¸°í™”");
          renderPlayerActionCards();
          renderStates();
        });

      document.getElementById("addMonsterBtn").addEventListener("click", () => {
        if (game.monsters.length >= 4) {
          log("âš ï¸ ëª¬ìŠ¤í„°ëŠ” ìµœëŒ€ 4ë§ˆë¦¬ì…ë‹ˆë‹¤.");
          return;
        }
        const name =
          (document.getElementById("mName").value || "").trim() ||
          `MONSTER${game.monsters.length + 1}`;
        const hpBase = clamp(
          +document.getElementById("mHpBase").value,
          50,
          5000
        );
        const vit = clamp(+document.getElementById("mVit").value, 1, 20);
        const atk = clamp(+document.getElementById("mAtk").value, 1, 20);
        const def = clamp(+document.getElementById("mDef").value, 1, 20);
        const agi = clamp(+document.getElementById("mAgi").value, 1, 20);

        const m = makeMonster({ name, vit, atk, def, agi, hpBase });
        game.monsters.push(m);
        log(`+ ëª¬ìŠ¤í„° ì¶”ê°€: ${m.name} HP ${m.maxHp}`);
        renderPlayerActionCards();
        renderStates();
      });

      document
        .getElementById("clearMonstersBtn")
        .addEventListener("click", () => {
          game.monsters = [];
          log("ëª¬ìŠ¤í„° ì´ˆê¸°í™”");
          renderPlayerActionCards();
          renderStates();
        });

      document
        .getElementById("startRoundBtn")
        .addEventListener("click", startRound);
      document
        .getElementById("resolveBtn")
        .addEventListener("click", resolveRound);

      document
        .getElementById("resetBattleBtn")
        .addEventListener("click", () => {
          game.round = 1;
          game.phase = "HINT";
          game.monsterIntents = null;
          game.actions.clear();

          // reset hp and states
          for (const p of game.players) {
            p.hp = p.maxHp;
            p.down = false;
            p.downCounter = 0;
            p.ultUsed = false;
            p.lastActiveKey = null;
            p.shields = [];
            p.debuffs = [];
            p.dots = [];
            p.redirect = null;
            p.tankingAll = false;
            p.minHpFloor = false;
            p._defendBonus = 0;
            p.endure = null;
            p.fightingSpirit = null;
            p.pendingAtkPlusNext = 0;
            p.temp = { atkPlus: 0, defPlus: 0, agiPlus: 0, vitPlus: 0 };
          }
          for (const m of game.monsters) {
            m.hp = m.maxHp;
            m.alive = true;
            m.debuffs = [];
            m.dots = [];
            m.shields = [];
            m.temp = { atkPlus: 0, defPlus: 0, agiPlus: 0, vitPlus: 0 };
          }

          log("\n=== ì „íˆ¬ ë¦¬ì…‹ ===");
          document.getElementById("hintBox").textContent =
            "ë¼ìš´ë“œ ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì•”ì‹œë¥¼ ìƒì„±í•˜ì„¸ìš”.";
          renderPlayerActionCards();
          renderStates();
        });

      document.getElementById("autoFillBtn").addEventListener("click", () => {
        if (game.phase !== "PLAYER") {
          log("âš ï¸ ìë™ ì…ë ¥ì€ PLAYER ë‹¨ê³„ì—ì„œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
          return;
        }
        const m = firstAliveMonster();
        for (const p of game.players) {
          if (p.down) continue;
          game.actions.set(p.id, {
            type: "ATTACK",
            skillKey: null,
            t1: m ? m.id : null,
            t2: null,
            stat: "atk",
          });
        }
        renderPlayerActionCards();
        log("ìë™ ì…ë ¥: ì „ì› ê¸°ë³¸ ê³µê²©");
      });

      document
        .getElementById("clearActionsBtn")
        .addEventListener("click", () => {
          game.actions.clear();
          renderPlayerActionCards();
          log("í–‰ë™ ì´ˆê¸°í™”");
        });

      document.getElementById("clearLogBtn").addEventListener("click", () => {
        game.logLines = [];
        document.getElementById("battleLog").textContent = "";
        renderStates();
      });

      document
        .getElementById("copyLogBtn")
        .addEventListener("click", async () => {
          const text = document.getElementById("battleLog").textContent;
          try {
            await navigator.clipboard.writeText(text);
            log("ë¡œê·¸ ë³µì‚¬ ì™„ë£Œ");
          } catch (e) {
            log("âš ï¸ ë¡œê·¸ ë³µì‚¬ ì‹¤íŒ¨ (ë¸Œë¼ìš°ì € ê¶Œí•œ í™•ì¸)");
          }
        });

      /* Initial render */
      renderPlayerActionCards();
      renderStates();
    </script>
  </body>
</html>
